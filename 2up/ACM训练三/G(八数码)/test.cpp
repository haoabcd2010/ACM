
/***************************************************
厉害的 IDA* + 曼哈顿 终于明白了迭代加深 评估函数
***************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

#define size 3          //这里规定几数码

int move[4][2]={{-1,0},{0,-1},{0,1},{1,0}};//上 左 右 下  置换顺序
char op[4]={'u','l','r','d'};

int map[size][size],map2[size*size],limit,path[100];
int flag,length;

// 十五数码 的表
//int goal[16][2]= {{size-1,size-1},{0,0},{0,1},{0,2},
//                  {0,3},{1,0},{1,1},{1,2},
//                  {1,3},{2,0},{2,1},{2,2},
//                  {2,3},{3,0},{3,1},{3,2}};//各个数字应在位置对照表

// 八数码 的表
int goal[9][2]= {{size-1,size-1},{0,0},{0,1},{0,2},
                                 {1,0},{1,1},{1,2},
                                 {2,0},{2,1}};      //各个数字应在位置对照表

int nixu(int a[size*size])
{
    int i,j,ni,w,x,y;  //w代表0的位置 下标，x y 代表0的数组坐标
    ni=0;
    for(i=0;i<size*size;i++)  //，size*size=16
    {
        if(a[i]==0)  //找到0的位置
            continue;//w=i;

        for(j=i+1;j<size*size;j++)  //注意！！每一个都跟其后所有的比一圈 查找小于i的个数相加
        {
            if (a[j]==0)continue;
            if(a[i]>a[j])
                ni++;
        }
    }
    //x=w/size;
    //y=w%size;
    //ni+=abs(x-(size-1))+abs(y-(size-1));  //最后加上0的偏移量
    if(ni%2==0)
        return 1;
    else
        return 0;
}

int hv(int a[][size])//估价函数，曼哈顿距离，小等于实际总步数
{
    int i,j,cost=0;
    for(i=0;i<size;i++)
    {
        for(j=0;j<size;j++)
        {
            int w=map[i][j];
            cost+=abs(i-goal[w][0])+abs(j-goal[w][1]);
        }
    }
    return cost;
}

void swap(int*a,int*b)
{
    int tmp;
    tmp=*a;
    *a=*b;
    *b=tmp;
}

void dfs(int sx,int sy,int len,int pre_move)//sx,sy是空格的位置
{
    int i,nx,ny;

    if(flag)
        return;

    int dv=hv(map); //现在的曼哈顿距离是

    if (len==limit)
    {
        if(dv==0)  //成功！ 退出
        {
            flag=1;
            length=len;
            return;
        }
        else
            return;  //超过预设长度 回退
    }
    else if(len<limit)
    {
        if(dv==0)  //短于预设长度 成功！退出
        {
            flag=1;
            length=len;
            return;
        }
    }

    for(i=0;i<4;i++)
    {
        if(i+pre_move== 3&& len>0)//不和上一次移动方向相反，对第二步以后而言
            continue;
        nx=sx+move[i][0];  //移动的四步 上左右下
        ny=sy+move[i][1];

        if( 0<=nx && nx<size && 0<=ny && ny<size )  //判断移动合理
        {
            swap(&map[sx][sy],&map[nx][ny]);
            int p=hv(map);   //移动后的 曼哈顿距离p=16

            if(p+len<=limit&&!flag)  //p+len<=limit&&!flag剪枝判断语句
            {
                path[len]=i;
                dfs(nx,ny,len+1,i);  //如当前步成功则 递归调用dfs
                if(flag)
                    return;
            }
            swap(&map[sx][sy],&map[nx][ny]);  //不合理则回退一步
        }
    }
}

int main()
{
    int pp;
    int i,j,k,sx,sy;
    char str[30];

    while(gets(str))
    {
        int slen = strlen(str);
        j=0;
        for(i=0;i<slen;i++)
        {
            if (str[i]==' ')
                continue;
            if (str[i]=='x')
                map2[j]=0;
            else
                map2[j]=str[i]-'0';
            j++;
        }

        for(i=0;i<size*size;i++)  //给map 和map2赋值map是二维数组，map2是一维数组
        {
            if(map2[i]==0)
            {
                map[i/size][i%size]=0;
                sx=i/size;
                sy=i%size;
            }
            else
            {
                map[i/size][i%size]=map2[i];
            }
        }
        flag=0,length=0;
        memset(path,-1,sizeof(path));  //已定义path[100]数组，将path填满-1
        if(nixu(map2)==1)                     //该状态可达
        {
            limit=hv(map);  //全部的曼哈顿距离之和
            while (!flag)
            {
                dfs(sx,sy,0,-1);
                if(!flag)
                  limit++; //得到的是最小步数
            }
            if(flag)
            {
                for(i=0;i<length;i++)
                printf("%c",op[path[i]]);  //根据path输出URLD路径
                printf("\n");
            }
        }
        else if(!nixu(map2)||!flag)
            printf("unsolvable\n");
    }
    return 0;
}

